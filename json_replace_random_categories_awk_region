#!/bin/bash
  #Считает количество строк в файле. авк обрезает выход от вс -л - он содержит полезную информацию только в $1
count_str_in_file=$(wc -l test_categories.csv | awk '{print $1}')
  #echo count_str_in_file: $count_str_in_file

randome="$(( $RANDOM % $count_str_in_file + 1 ))"
categ_id=$(cat test_categories.csv | awk 'BEGIN{FS=";"}{print $2}' | sed -n "$randome p" | tr -d '\r')
echo categ_id: $categ_id

  #Запись рандомной категории в джсон

#jq --arg d ${categ_id} '.shops.categories[0] = $d' config.json > "tmp" && mv "tmp" config.json



  #Блок получения и записи тт_ид

user_input_tt_id=$1
if [ -n "$user_input_tt_id" ]
then
	echo user_input_tt_id: $user_input_tt_id

	#Блок записи тт_ид (если введена)
  
	jq --arg d "${user_input_tt_id}" '.shops.id = $d' config.json > "tmp" && mv "tmp" config.json

else
	echo "user_input_tt_id: none"


fi


  #Блок получения и записи региона - ищет строку по введённому человеком тт_ид, из строки вынимает регион_ид, удаляет символ возврата коретки; так же вынимает имя региона. Если не введён тт_ид, не отрабатывает

if [ -n "$user_input_tt_id" ]
then

	#Блок получения регион_ид через awk
	
reg_id=$(cat shops.csv | awk 'BEGIN{FS=";"}{
if ($2 ~ var_in_awk)
{
print $0
}
}' var_in_awk="${user_input_tt_id}" | awk 'BEGIN{FS=";"}{print $8}' | tr -d '\r')

echo reg_id: $reg_id

  #Блок записи рег_ид в конфиг; регнэйм при этом не пишется, а просто выводится на экран для простоты дебага
  
#jq --arg d "${reg_id}" '.shops.region_id = $d' config.json > "tmp" && mv "tmp" config.json

fi

  #Блок запуска

if [ -n "$reg_id" ]
then

sleep 2s
#pipenv run bash run.sh 

else
	echo "Парсер не запущен" 

fi



#-----------------2023-08-10
#Кейс: битва с кавычками
#i=1234

#jq --argjson d "$i" '.chain_id = $d' config.json #работает - пишет число в поле чайн_ид

#jq --argjson d "$categ_id" '.shops[0].categories[0] = $d' config.json #работает на реальном примере



#---------------2023-08-18
#Кейс: поиск по вхождению в файл через grep -e (регулярка), с использованием переменной
#find `echo "${searchpath}"` -type f -print0 | xargs -0 grep -l -E '"${string1}".*"${string2}".*"${string3}"'


#Кейс: удаление специсмволов
#tr -d '\r' - видит спецсимволы и удаляет их
#cat shops.csv | grep -e "$user_input_tt_id" | awk 'BEGIN{FS=";"}{print $8}' | tr -d '\r'
# od -c - показывает все спецсимволы и их запись в виде нулей и единиц


#Кейс: получить номер строки, в которой есть вхождение тт_ид, но вхождение тт_ид может быть и в координатах - потмоу сначало надо отфильтровать файл и оставить только тт_ид и строку
#А потом взять номер строки, вытащить строку по номеру и уже из этой строки - вытащить рег_ид
 
 #блок получения номера строки, содержащий тт_ид - тт_ид встречается в координатах, потом греп может давать много строк. Логика фильтрует строки по 2-му столбцу и берёт номер строки

#str_num=$(cat shops.csv | awk 'BEGIN{FS=";"}{print $2,FNR}' | grep -E "${user_input_tt_id}" | awk '{print $2}')
#echo str_num $str_num

  #Блок получения рег_ид из строки с номером str_num
#reg_id=$(cat shops.csv | sed -n "$str_num p" | awk 'BEGIN{FS=";"}{print $8}')
#echo reg_id: $reg_id


  #Кейс: использование расширенных регулярный выражений в греп, с переменными
#cat shops.csv | awk 'BEGIN{FS=";"}{print $2}' | grep -E "^${user_input_tt_id}$"
#cat shops.csv | awk 'BEGIN{FS=";"}{print $2}' | grep -E "^262$"


  #Кейс:
    #блок получения номера строки, содержащий тт_ид - тт_ид встречается в координатах, потом греп может давать много строк. Логика фильтрует строки по 2-му столбцу, 
    #выводит все строки файла в "виде ттид_номерстроки" - в этом выводе присутствует нижнее подчёркивание, далее греп ищет по тт_ид в начале и _ нижнему подчёрккиванию вконце (чтобы отфильтровать входления коротких тт ид в другие номера, например 262)
    #Далее из вывода записывается только номер строки в переменную стр_нум
	

#str_num=$(cat shops.csv | awk 'BEGIN{FS=";"; OFS="_"}{print $2,FNR}' | grep -E "^${user_input_tt_id}_" | awk 'BEGIN{FS="_"}{print $2}')



#-----------2023-08-26
#Получение строки с тт_ид, без sed. Через условие в awk - если $1 совпадает с введённой тт_ид, то выводится вся строка с этим совпадением. Далее из выведенной строки можно вытащить уже регион

#cat shops.csv | awk 'BEGIN{FS=";"}{
#if ($1 ~ var_in_awk)
#{
#print $0
#}
#}' var_in_awk="${user_input_tt_id}" | awk 'BEGIN{FS=";"}{print $3}' | tr -d '\r'


#------------2023-08-28
#Переменную засунуть в wc -l

#count_str_in_file=$(wc -l <<< "$test_categ_file" | awk '{print $1}')



